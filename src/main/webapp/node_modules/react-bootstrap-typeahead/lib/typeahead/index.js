'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var React = require('react');
var ReactDOM = require('react-dom');
var TypeaheadSelector = require('./selector');
var KeyEvent = require('../keyevent');
var fuzzy = require('fuzzy');
var classNames = require('classnames');
var Input = require('react-bootstrap').Input;
var Button = require('react-bootstrap').Button;
var Glyphicon = require('react-bootstrap').Glyphicon;

var IDENTITY_FN = function IDENTITY_FN(input) {
    return input;
};
var SHOULD_SEARCH_VALUE = function SHOULD_SEARCH_VALUE(input) {
    return input && input.trim().length > 0;
};
var _generateAccessor = function _generateAccessor(field) {
    return function (object) {
        return object[field];
    };
};

/**
 * A "typeahead", an auto-completing text input
 *
 * Renders an text input that shows options nearby that you can use the
 * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.
 */
var Typeahead = React.createClass({
    displayName: 'Typeahead',

    propTypes: {
        name: React.PropTypes.string,
        customClasses: React.PropTypes.object,
        maxVisible: React.PropTypes.number,
        options: React.PropTypes.array,
        allowCustomValues: React.PropTypes.number,
        defaultValue: React.PropTypes.string,
        value: React.PropTypes.string,
        placeholder: React.PropTypes.string,
        textarea: React.PropTypes.bool,
        inputProps: React.PropTypes.object,
        onOptionSelected: React.PropTypes.func,
        onChange: React.PropTypes.func,
        onKeyDown: React.PropTypes.func,
        onKeyUp: React.PropTypes.func,
        onFocus: React.PropTypes.func,
        onBlur: React.PropTypes.func,
        filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        defaultClassNames: React.PropTypes.bool,
        customListComponent: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.func]),
        optionsButton: React.PropTypes.bool
    },

    getDefaultProps: function getDefaultProps() {
        return {
            options: [],
            customClasses: {},
            allowCustomValues: 0,
            defaultValue: '',
            value: null,
            placeholder: "",
            textarea: false,
            inputProps: {},
            onOptionSelected: function onOptionSelected(option) {},
            onChange: function onChange(event) {},
            onKeyDown: function onKeyDown(event) {},
            onKeyUp: function onKeyUp(event) {},
            onFocus: function onFocus(event) {},
            onBlur: function onBlur(event) {},
            filterOption: null,
            defaultClassNames: true,
            customListComponent: TypeaheadSelector,
            optionsButton: false
        };
    },

    getInitialState: function getInitialState() {
        return {
            // The currently visible set of options
            visible: this.getOptionsForValue(this.props.defaultValue, this.props.options),

            // This should be called something else, "entryValue"
            entryValue: this.props.value || this.props.defaultValue,

            // A valid typeahead value
            selection: this.props.value,

            // Whether to show options even though nothing has been typed in
            showOptions: false,

            // Index of the selection
            selectionIndex: null
        };
    },

    getOptionsForValue: function getOptionsForValue(value, options) {
        if (!SHOULD_SEARCH_VALUE(value)) {
            return options;
        }
        var filterOptions = this._generateFilterFunction();
        var result = filterOptions(value, options);
        if (this.props.maxVisible) {
            result = result.slice(0, this.props.maxVisible);
        }
        return result;
    },

    /**
     * Gets currently visible options.
     */
    getCurrentOptions: function getCurrentOptions() {
        return this.state.visible;
    },

    _onPageClick: function _onPageClick(e) {
        if (!this._withinOptionsToggle(e) && !this._withinResultList(e) && this.state.showOptions) {
            this.setState({ showOptions: false });
        }
        return true;
    },

    _withinOptionsToggle: function _withinOptionsToggle(e) {
        if (!this.refs.optionsToggle) {
            return false;
        }
        return this._withinRect(e, ReactDOM.findDOMNode(this.refs.optionsToggle).getBoundingClientRect());
    },

    _withinResultList: function _withinResultList(e) {
        return this._withinRect(e, ReactDOM.findDOMNode(this.refs.sel).getBoundingClientRect());
    },

    _withinRect: function _withinRect(e, rect) {
        // Don't forget that root is top left corner, so rect.bottom is always >= rect.top
        return e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
    },

    setEntryText: function setEntryText(value) {
        this.refs.entry.getInputDOMNode().value = value;
        this._onTextEntryUpdated();
    },

    focus: function focus() {
        this.refs.entry.getInputDOMNode().focus();
    },

    showOptions: function showOptions() {
        this.setState({ showOptions: true });
    },

    hideOptions: function hideOptions() {
        this.setState({ showOptions: false });
    },

    _hasCustomValue: function _hasCustomValue() {
        return !!(this.props.allowCustomValues > 0 && this.state.entryValue.length >= this.props.allowCustomValues && this.state.visible.indexOf(this.state.entryValue) < 0);
    },

    _getCustomValue: function _getCustomValue() {
        if (this._hasCustomValue()) {
            return this.state.entryValue;
        }
        return null;
    },

    _renderIncrementalSearchResults: function _renderIncrementalSearchResults() {
        // If not forced to show options
        if (!this.state.showOptions) {
            window.removeEventListener('mousedown', this._onPageClick, false);
            // Nothing has been entered into the textbox
            if (!this.state.entryValue) {
                return "";
            }

            // Something was just selected
            if (this.state.selection) {
                return "";
            }
        } else {
            window.addEventListener('mousedown', this._onPageClick, false);
        }

        return React.createElement(this.props.customListComponent, {
            ref: 'sel', options: this.state.visible,
            onOptionSelected: this._onOptionSelected,
            customValue: this._getCustomValue(),
            customClasses: this.props.customClasses,
            selectionIndex: this.state.selectionIndex,
            defaultClassNames: this.props.defaultClassNames,
            displayOption: this._generateOptionToStringFor(this.props.displayOption) });
    },

    getSelection: function getSelection() {
        var index = this.state.selectionIndex;
        if (this._hasCustomValue()) {
            if (index === 0) {
                return this.state.entryValue;
            } else {
                index--;
            }
        }
        return this.state.visible[index];
    },

    _onOptionSelected: function _onOptionSelected(option, event) {
        this.selectOption(option);
        return this.props.onOptionSelected(option, event);
    },

    selectOption: function selectOption(option) {
        window.removeEventListener('mousedown', this._onPageClick, false);
        var nEntry = this.refs.entry.getInputDOMNode();
        // nEntry.focus();

        var displayOption = this._generateOptionToStringFor(this.props.displayOption);
        var optionString = displayOption(option, 0);

        var formInputOption = this._generateOptionToStringFor(this.props.formInputOption || displayOption);
        var formInputOptionString = formInputOption(option);

        nEntry.value = optionString;
        this.setState({
            visible: this.getOptionsForValue(optionString, this.props.options),
            selection: formInputOptionString,
            showOptions: false,
            entryValue: optionString
        });
    },

    _onTextEntryUpdated: function _onTextEntryUpdated() {
        var value = this.refs.entry.getValue();
        this.setState({
            visible: this.getOptionsForValue(value, this.props.options),
            selection: '',
            showOptions: false,
            entryValue: value
        });
    },

    _onEnter: function _onEnter(event) {
        var selection = this.getSelection();
        if (!selection) {
            return this.props.onKeyDown(event);
        }
        return this._onOptionSelected(selection, event);
    },

    _onEscape: function _onEscape() {
        this.setState({
            showOptions: false,
            selectionIndex: null
        });
    },

    _onTab: function _onTab(event) {
        var selection = this.getSelection();
        var option = selection ? selection : this.state.visible.length > 0 ? this.state.visible[0] : null;

        if (option === null && this._hasCustomValue()) {
            option = this._getCustomValue();
        }

        if (option !== null) {
            return this._onOptionSelected(option, event);
        }
    },

    eventMap: function eventMap(event) {
        var events = {};

        events[KeyEvent.DOM_VK_UP] = this.navUp;
        events[KeyEvent.DOM_VK_DOWN] = this.navDown;
        events[KeyEvent.DOM_VK_RETURN] = events[KeyEvent.DOM_VK_ENTER] = this._onEnter;
        events[KeyEvent.DOM_VK_ESCAPE] = this._onEscape;
        events[KeyEvent.DOM_VK_TAB] = this._onTab;

        return events;
    },

    _nav: function _nav(delta) {
        if (!this._hasHint()) {
            return;
        }
        var newIndex = this.state.selectionIndex === null ? delta == 1 ? 0 : delta : this.state.selectionIndex + delta;
        var length = this.state.visible.length;
        if (this._hasCustomValue()) {
            length += 1;
        }

        if (newIndex < 0) {
            newIndex += length;
        } else if (newIndex >= length) {
            newIndex -= length;
        }

        this.setState({ selectionIndex: newIndex });
    },

    navDown: function navDown() {
        this._nav(1);
    },

    navUp: function navUp() {
        this._nav(-1);
    },

    _onChange: function _onChange(event) {
        if (this.props.onChange) {
            this.props.onChange(event);
        }

        this._onTextEntryUpdated();
    },

    _onKeyDown: function _onKeyDown(event) {
        // If there are no visible elements, don't perform selector navigation.
        // Just pass this up to the upstream onKeydown handler.
        // Also skip if the user is pressing the shift key, since none of our handlers are looking for shift
        if (!this._hasHint() || event.shiftKey) {
            return this.props.onKeyDown(event);
        }

        var handler = this.eventMap()[event.keyCode];

        if (handler) {
            handler(event);
        } else {
            return this.props.onKeyDown(event);
        }
        // Don't propagate the keystroke back to the DOM/browser
        event.preventDefault();
    },

    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState({
            visible: this.getOptionsForValue(this.refs.entry.getValue(), nextProps.options)
        });
    },

    _onToggleShowOptions: function _onToggleShowOptions() {
        this.setState({ showOptions: !this.state.showOptions });
    },

    render: function render() {
        var inputClasses = {};
        inputClasses[this.props.customClasses.input] = !!this.props.customClasses.input;
        var inputClassList = classNames(inputClasses);

        var classes = {
            typeahead: this.props.defaultClassNames
        };
        classes[this.props.className] = !!this.props.className;
        var classList = classNames(classes);

        return React.createElement(
            'div',
            { className: classList },
            this._renderHiddenInput(),
            React.createElement(Input, (0, _extends3.default)({ ref: 'entry', type: 'text'
            }, this.props.inputProps, {
                placeholder: this.props.placeholder,
                className: inputClassList,
                value: this.state.entryValue,
                onChange: this._onChange,
                onKeyDown: this._onKeyDown,
                onKeyUp: this.props.onKeyUp,
                onFocus: this.props.onFocus,
                onBlur: this.props.onBlur,
                buttonAfter: this._renderShowOptionsButton()
            })),
            this._renderIncrementalSearchResults()
        );
    },

    _renderHiddenInput: function _renderHiddenInput() {
        if (!this.props.name) {
            return null;
        }

        return React.createElement('input', {
            type: 'hidden',
            name: this.props.name,
            value: this.state.selection ? this.state.selection : ''
        });
    },

    _renderShowOptionsButton: function _renderShowOptionsButton() {
        if (!this.props.optionsButton) {
            return '';
        }
        return React.createElement(
            Button,
            { ref: 'optionsToggle', title: 'Show options', bsSize: 'small', onClick: this._onToggleShowOptions },
            React.createElement(Glyphicon, { glyph: 'triangle-bottom' })
        );
    },

    _generateFilterFunction: function _generateFilterFunction() {
        var filterOptionProp = this.props.filterOption;
        if (typeof filterOptionProp === 'function') {
            return function (value, options) {
                return options.filter(function (o) {
                    return filterOptionProp(value, o);
                });
            };
        } else {
            var mapper;
            if (typeof filterOptionProp === 'string') {
                mapper = _generateAccessor(filterOptionProp);
            } else {
                mapper = IDENTITY_FN;
            }
            return function (value, options) {
                return fuzzy.filter(value, options, { extract: mapper }).map(function (res) {
                    return options[res.index];
                });
            };
        }
    },

    _generateOptionToStringFor: function _generateOptionToStringFor(prop) {
        if (typeof prop === 'string') {
            return _generateAccessor(prop);
        } else if (typeof prop === 'function') {
            return prop;
        } else {
            return IDENTITY_FN;
        }
    },

    _hasHint: function _hasHint() {
        return this.state.visible.length > 0 || this._hasCustomValue();
    }
});

module.exports = Typeahead;