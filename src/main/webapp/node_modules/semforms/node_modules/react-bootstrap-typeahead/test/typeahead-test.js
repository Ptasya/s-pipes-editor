const _ = require('lodash');
const assert = require('chai').assert;
const sinon = require('sinon');
const React = require('react');
const ReactDOM = require('react-dom');
const Typeahead = require('../src/typeahead');
const TypeaheadOption = require('../src/typeahead/option');
const TypeaheadSelector = require('../src/typeahead/selector');
const Keyevent = require('../src/keyevent');
const TestUtils = require('react-addons-test-utils');

function simulateTextInput(component, value) {
    const node = ReactDOM.findDOMNode(component.entry);
    node.value = value;
    TestUtils.Simulate.change(node);
    return TestUtils.scryRenderedComponentsWithType(component, TypeaheadOption);
}

const BEATLES = ['John', 'Paul', 'George', 'Ringo'];

const BEATLES_COMPLEX = [
    {
        firstName: 'John',
        lastName: 'Lennon',
        nameWithTitle: 'John Winston Ono Lennon MBE'
    }, {
        firstName: 'Paul',
        lastName: 'McCartney',
        nameWithTitle: 'Sir James Paul McCartney MBE'
    }, {
        firstName: 'George',
        lastName: 'Harrison',
        nameWithTitle: 'George Harrison MBE'
    }, {
        firstName: 'Ringo',
        lastName: 'Starr',
        nameWithTitle: 'Richard Starkey Jr. MBE'
    }
];

describe('Typeahead Component', function () {

    describe('sanity', function () {
        beforeEach(function () {
            this.component = TestUtils.renderIntoDocument(<Typeahead options={BEATLES} optionsButton={true}/>);
        });

        it('should fuzzy search and render matching results', function () {
            // input value: num of expected results
            const testplan = {
                    'o': 3,
                    'pa': 1,
                    'Grg': 1,
                    'Ringo': 1,
                    'xxx': 0
                },
                self = this;
            _.each(testplan, function (expected, value) {
                const results = simulateTextInput(self.component, value);
                assert.equal(results.length, expected, 'Text input: ' + value);
            });
        });

        it('does not change the url hash when clicking on options', function () {
            const results = simulateTextInput(this.component, 'o');
            const firstResult = results[0];
            const anchor = TestUtils.findRenderedDOMComponentWithTag(firstResult, 'a');
            const href = ReactDOM.findDOMNode(anchor).getAttribute('href');
            assert.notEqual(href, '#');
        });

        it('resets input value to the already selected one when input looses focus', function (done) {
            this.component.selectOption(BEATLES[0]);
            simulateTextInput(this.component, '0');
            TestUtils.Simulate.blur(ReactDOM.findDOMNode(this.component.entry));
            setTimeout(function () {
                done();
                assert.equal(BEATLES[0], ReactDOM.findDOMNode(this.component.entry).value);
            }.bind(this), 500);
        });

        it('hides selector on input blur when resting value to its original', function (done) {
            simulateTextInput(this.component, '0');
            TestUtils.Simulate.blur(ReactDOM.findDOMNode(this.component.entry));
            setTimeout(function () {
                done();
                assert.equal('', ReactDOM.findDOMNode(this.component.entry).value);
                const selector = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadSelector);
                assert.equal(0, selector.length);
            }.bind(this), 100);
        });

        it('removes scheduled input reset when component is about to be unmounted', function (done) {
            this.component.selectOption(BEATLES[0]);
            simulateTextInput(this.component, '0');
            TestUtils.Simulate.blur(ReactDOM.findDOMNode(this.component.entry));
            this.component.componentWillUnmount();
            setTimeout(function () {
                done();
                assert.equal('0', ReactDOM.findDOMNode(this.component.entry).value);
            }.bind(this), 500);
        });

        it('does nothing when blur is triggered after selection reset', function (done) {
            this.component = TestUtils.renderIntoDocument(<Typeahead options={BEATLES} allowReset={true}/>);
            this.component.selectOption(BEATLES[0]);
            const resetButton = TestUtils.findRenderedDOMComponentWithTag(this.component, 'button');
            TestUtils.Simulate.click(resetButton);
            assert.equal('', this.component.state.entryValue);
            const input = ReactDOM.findDOMNode(this.component.entry);
            TestUtils.Simulate.focus(input);
            TestUtils.Simulate.blur(input);
            setTimeout(function () {
                done();
                assert.equal('', input.value);
            }.bind(this), 500);
        });


        describe('keyboard controls', function () {
            it('down arrow + return selects an option', function () {
                var results = simulateTextInput(this.component, 'o');
                var secondItem = ReactDOM.findDOMNode(results[1]).innerText;
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_RETURN});
                assert.equal(node.value, secondItem); // Poor Ringo
            });

            it('up arrow + return navigates and selects an option', function () {
                var results = simulateTextInput(this.component, 'o');
                var firstItem = ReactDOM.findDOMNode(results[0]).innerText;
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_UP});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_RETURN});
                assert.equal(node.value, firstItem);
            });

            it('escape clears selection', function () {
                var results = simulateTextInput(this.component, 'o');
                var firstItem = ReactDOM.findDOMNode(results[0]);
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                assert.ok(firstItem.classList.contains('hover'));
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_ESCAPE});
                assert.notOk(firstItem.classList.contains('hover'));
            });

            it('tab to choose first item', function () {
                var results = simulateTextInput(this.component, 'o');
                var itemText = ReactDOM.findDOMNode(results[0]).innerText;
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_TAB});
                assert.equal(node.value, itemText);
            });

            it('tab to selected current item', function () {
                var results = simulateTextInput(this.component, 'o');
                var itemText = ReactDOM.findDOMNode(results[1]).innerText;
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_TAB});
                assert.equal(node.value, itemText);
            });

            it('tab on no selection should not be undefined', function () {
                var results = simulateTextInput(this.component, 'oz');
                assert(results.length == 0);
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_TAB});
                assert.equal("oz", node.value);
            });

            it('should set hover', function () {
                var results = simulateTextInput(this.component, 'o');
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                assert.equal(true, results[1].props.hover);
            });
        });

        describe('component functions', function () {
            beforeEach(function () {
                this.sinon = sinon.sandbox.create();
            });
            afterEach(function () {
                this.sinon.restore();
            });
            it('focuses the typeahead', function () {
                var node = ReactDOM.findDOMNode(this.component.entry);
                this.sinon.spy(node, 'focus');
                this.component.focus();
                assert.equal(node.focus.calledOnce, true);
            });
            it('shows the options', function () {
                var options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, 0);
                this.component.showOptions();
                options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, BEATLES.length);
            });
            it('hides the options', function () {
                this.component.showOptions();
                var options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, BEATLES.length);
                this.component.hideOptions();
                options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, 0);
            });

            it('returns entry text', function () {
                var input = ReactDOM.findDOMNode(this.component.entry),
                    value = "o";
                input.value = value;
                TestUtils.Simulate.change(input);
                var result = this.component.getEntryText();
                assert.equal(result, value);
            });
        });

        describe('on-demand options display', function () {
            beforeEach(function () {
                this.sinon = sinon.sandbox.create();
            });
            afterEach(function () {
                this.sinon.restore();
            });
            it('shows options when toggle is clicked', function () {
                var button = ReactDOM.findDOMNode(this.component.optionsToggle);
                TestUtils.Simulate.click(button);
                var options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, BEATLES.length);
            });
            it('hides options when toggle is clicked again', function () {
                var button = ReactDOM.findDOMNode(this.component.optionsToggle);
                TestUtils.Simulate.click(button);
                var options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, BEATLES.length);
                TestUtils.Simulate.click(button);
                options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, 0);
            });
            it('hides options when user clicks somewhere else in document', function () {
                this.component.showOptions();
                var options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, BEATLES.length);
                var evt = {
                    clientX: 1,
                    clientY: 1
                };
                this.component._onPageClick(evt);
                options = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(options.length, 0);
            });
        });
    });

    describe('props', function () {
        context('maxVisible', function () {
            it('limits the result set based on the maxVisible option', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } maxVisible={ 1 }/>);
                var results = simulateTextInput(component, 'o');
                assert.equal(results.length, 1);
            });
        });

        context('displayOption', function () {
            it('renders simple options verbatim when not specified', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead
                    options={ BEATLES }
                />);
                var results = simulateTextInput(component, 'john');
                assert.equal(ReactDOM.findDOMNode(results[0]).textContent, 'John');
            });

            it('renders custom options when specified as a string', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead
                    options={ BEATLES_COMPLEX }
                    filterOption='firstName'
                    displayOption='nameWithTitle'
                />);
                var results = simulateTextInput(component, 'john');
                assert.equal(ReactDOM.findDOMNode(results[0]).textContent, 'John Winston Ono Lennon MBE');
            });

            it('renders custom options when specified as a function', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead
                    options={ BEATLES_COMPLEX }
                    filterOption='firstName'
                    displayOption={ function (o, i) {
                        return i + ' ' + o.firstName + ' ' + o.lastName;
                    } }
                />);
                var results = simulateTextInput(component, 'john');
                assert.equal(ReactDOM.findDOMNode(results[0]).textContent, '0 John Lennon');
            });
        });

        context('allowCustomValues', function () {

            beforeEach(function () {
                this.sinon = sinon.sandbox.create();
                this.selectSpy = this.sinon.spy();
                this.component = TestUtils.renderIntoDocument(<Typeahead options={BEATLES} allowCustomValues={3}
                                                                         onOptionSelected={this.selectSpy}></Typeahead>);
            });

            afterEach(function () {
                this.sinon.restore();
            })

            it('should not display custom value if input length is less than entered', function () {
                var input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "zz";
                TestUtils.Simulate.change(input);
                var results = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(0, results.length);
                assert.equal(false, this.selectSpy.called);
            });

            it('should display custom value if input exceeds props.allowCustomValues', function () {
                var input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "ZZZ";
                TestUtils.Simulate.change(input);
                var results = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                assert.equal(1, results.length);
                assert.equal(false, this.selectSpy.called);
            });

            it('should call onOptionSelected when selecting from options', function () {
                var results = simulateTextInput(this.component, 'o');
                var firstItem = ReactDOM.findDOMNode(results[0]).innerText;
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_UP});
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_RETURN});

                assert.equal(true, this.selectSpy.called);
                assert(this.selectSpy.calledWith(firstItem));
            })

            it('should call onOptionSelected when custom value is selected', function () {
                var input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "ZZZ";
                TestUtils.Simulate.change(input);
                TestUtils.Simulate.keyDown(input, {keyCode: Keyevent.DOM_VK_DOWN});
                TestUtils.Simulate.keyDown(input, {keyCode: Keyevent.DOM_VK_RETURN});
                assert.equal(true, this.selectSpy.called);
                assert(this.selectSpy.calledWith(input.value));
            })

            it('should add hover prop to customValue', function () {
                var input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "ZZZ";
                TestUtils.Simulate.change(input);
                var results = TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                TestUtils.Simulate.keyDown(input, {keyCode: Keyevent.DOM_VK_DOWN});
                assert.equal(true, results[0].props.hover)
            })


        });

        context('customClasses', function () {

            before(function () {
                var customClasses = {
                    input: 'topcoat-text-input',
                    results: 'topcoat-list__container',
                    listItem: 'topcoat-list__item',
                    listAnchor: 'topcoat-list__link',
                    hover: 'topcoat-list__item-active'
                };

                this.component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                         customClasses={ customClasses }></Typeahead>);

                simulateTextInput(this.component, 'o');
            });

            it('adds a custom class to the typeahead input', function () {
                var input = ReactDOM.findDOMNode(this.component.entry);
                assert.isTrue(input.classList.contains('topcoat-text-input'));
            });

            it('adds a custom class to the results component', function () {
                var results = ReactDOM.findDOMNode(TestUtils.findRenderedComponentWithType(this.component,
                    TypeaheadSelector));
                assert.isTrue(results.classList.contains('topcoat-list__container'));
            });
            it('adds a custom class to the list items ', function () {
                var typeaheadOptions =
                    TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                var listItem = ReactDOM.findDOMNode(typeaheadOptions[1]);
                assert.isTrue(listItem.classList.contains('topcoat-list__item'));
            });
            it('adds a custom class to the option anchor tags', function () {
                var typeaheadOptions =
                    TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                var listAnchor =
                    typeaheadOptions[1].refs.anchor;
                assert.isTrue(listAnchor.classList.contains('topcoat-list__link'));
            });
            it('adds a custom class to the list items when active', function () {
                var typeaheadOptions =
                    TestUtils.scryRenderedComponentsWithType(this.component, TypeaheadOption);
                var node = ReactDOM.findDOMNode(this.component.entry);
                TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                var listItem = typeaheadOptions[0];
                var domListItem = ReactDOM.findDOMNode(listItem);
                assert.isTrue(domListItem.classList.contains('topcoat-list__item-active'));
            });
        });
        context('defaultValue', function () {
            it('should perform an initial search if a default value is provided', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } defaultValue={ 'o' }/>);
                var results = TestUtils.scryRenderedComponentsWithType(component, TypeaheadOption);
                assert.equal(results.length, 3);
            });
        });
        context('value', function () {
            it('should set input value', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } value={ 'John' }/>);
                var input = component.entry;
                assert.equal(ReactDOM.findDOMNode(input).value, 'John');
            });
        });
        context('onKeyDown', function () {
            it('should bind to key events on the input', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                        onKeyDown={ function (e) {
                                                                            assert.equal(e.keyCode, 87);
                                                                        } }/>);
                var input = ReactDOM.findDOMNode(component.entry);
                TestUtils.Simulate.keyDown(input, {keyCode: 87});
            });
        });
        context('onKeyUp', function () {
            it('should bind to key events on the input', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                        onKeyUp={ function (e) {
                                                                            assert.equal(e.keyCode, 87);
                                                                        } }/>);
                var input = ReactDOM.findDOMNode(component.entry);
                TestUtils.Simulate.keyUp(input, {keyCode: 87});
            });
        });
        context('inputProps', function () {
            it('should forward props to the input element', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                        inputProps={{autoCorrect: 'off'}}/>);
                var input = ReactDOM.findDOMNode(component.entry);
                assert.equal(input.getAttribute('autoCorrect'), 'off');
            });
        });
        context('defaultClassNames', function () {
            it('should remove default classNames when this prop is specified and false', function () {
                var component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                        defaultClassNames={false}/>);
                simulateTextInput(component, 'o');
                assert.notOk(ReactDOM.findDOMNode(component).classList.contains("typeahead"));
                assert.notOk(ReactDOM.findDOMNode(component.sel).classList.contains("typeahead-selector"));
            });
        });
        context('filterOption', function () {
            const FN_TEST_PLANS = [{
                name: 'accepts everything', fn: function () {
                    return true;
                }, input: 'xxx', output: 4
            }, {
                name: 'rejects everything', fn: function () {
                    return false;
                }, input: 'o', output: 0
            }];
            _.each(FN_TEST_PLANS, function (testplan) {
                it('should filter with a custom function that ' + testplan.name, function () {
                    const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                              filterOption={ testplan.fn }/>);
                    const results = simulateTextInput(component, testplan.input);
                    assert.equal(results.length, testplan.output);
                });
            });
            const STRING_TEST_PLANS = {'o': 3, 'pa': 1, 'Grg': 1, 'Ringo': 1, 'xxx': 0};
            it('should filter using fuzzy matching on the provided field name', function () {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES_COMPLEX }
                                                                          filterOption='firstName'
                                                                          displayOption='firstName'/>);
                _.each(STRING_TEST_PLANS, function (expected, value) {
                    const results = simulateTextInput(component, value);
                    assert.equal(results.length, expected, 'Text input: ' + value);
                }, this);
            });
        });
        context('formInputOption', function () {
            const FORM_INPUT_TEST_PLANS = [{
                name: 'uses simple options verbatim when not specified',
                props: {options: BEATLES},
                output: 'John'
            }, {
                name: 'defaults to the display string when not specified',
                props: {options: BEATLES_COMPLEX, filterOption: 'firstName', displayOption: 'nameWithTitle'},
                output: 'John Winston Ono Lennon MBE'
            }, {
                name: 'uses custom options when specified as a string',
                props: {
                    options: BEATLES_COMPLEX,
                    filterOption: 'firstName',
                    displayOption: 'nameWithTitle',
                    formInputOption: 'lastName'
                },
                output: 'Lennon'
            }, {
                name: 'uses custom optinos when specified as a function',
                props: {
                    options: BEATLES_COMPLEX,
                    filterOption: 'firstName',
                    displayOption: 'nameWithTitle',
                    formInputOption: function (o, i) {
                        return o.firstName + ' ' + o.lastName;
                    }
                },
                output: 'John Lennon'
            }];
            _.each(FORM_INPUT_TEST_PLANS, function (testplan) {
                it(testplan.name, function () {
                    const component = TestUtils.renderIntoDocument(<Typeahead {...testplan.props} name='beatles'/>),
                        results = simulateTextInput(component, 'john'),
                        node = ReactDOM.findDOMNode(component.entry);
                    TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_DOWN});
                    TestUtils.Simulate.keyDown(node, {keyCode: Keyevent.DOM_VK_RETURN});
                    assert.equal(component.state.selection, testplan.output);
                });
            });
        });
        context('customListComponent', function () {
            before(function () {
                const ListComponent = React.createClass({
                    render: function () {
                        return <div></div>;
                    }
                });
                this.ListComponent = ListComponent;
            });
            beforeEach(function () {
                this.component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }
                                                                         customListComponent={this.ListComponent}/>);
            });
            it('should not show the customListComponent when the input is empty', function () {
                const results = TestUtils.scryRenderedComponentsWithType(this.component, this.ListComponent);
                assert.equal(0, results.length);
            });
            it('should show the customListComponent when the input is not empty', function () {
                const input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "o";
                TestUtils.Simulate.change(input);
                const results = TestUtils.scryRenderedComponentsWithType(this.component, this.ListComponent);
                assert.equal(1, results.length);
            });
            it('should no longer show the customListComponent after an option has been selected', function () {
                const input = ReactDOM.findDOMNode(this.component.entry);
                input.value = "o";
                TestUtils.Simulate.change(input);
                TestUtils.Simulate.keyDown(input, {keyCode: Keyevent.DOM_VK_TAB});
                const results = TestUtils.scryRenderedComponentsWithType(this.component, this.ListComponent);
                assert.equal(0, results.length);
            });
        });
        context('input', function () {
            it('should render a <input> input', function () {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }/>);

                const input = component.entry;
                assert.equal(ReactDOM.findDOMNode(input).tagName.toLowerCase(), 'input');
            });
        });
        context('optionsButton', function () {

            it('does not show options button by default', function () {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES }/>);
                assert.isUndefined(component.optionsToggle);
            });
            it('shows options button when property set to true', function () {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } optionsButton={true}/>);
                assert.isDefined(component.optionsToggle);
            });

            it('displays all options when input is empty and options button is clicked', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } optionsButton={true}/>),
                    button = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
                TestUtils.Simulate.click(button);
                const selector = TestUtils.findRenderedComponentWithType(component, TypeaheadSelector);
                assert.equal(BEATLES, selector.props.options);
            });

            it('displays all options when value is set and options button is clicked', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } optionsButton={true}
                                                                          value={BEATLES[0]}/>),
                    button = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
                TestUtils.Simulate.click(button);
                const selector = TestUtils.findRenderedComponentWithType(component, TypeaheadSelector);
                assert.equal(BEATLES, selector.props.options);
            });

            it('displays all options when value is selected and options button is clicked', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } optionsButton={true}
                                                                          value={BEATLES[0]}/>);
                let button = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
                TestUtils.Simulate.click(button);
                let selector = TestUtils.findRenderedComponentWithType(component, TypeaheadSelector);
                const options = TestUtils.scryRenderedDOMComponentsWithTag(selector, 'li');
                TestUtils.Simulate.click(options[0]);
                button = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
                TestUtils.Simulate.click(button);
                selector = TestUtils.findRenderedComponentWithType(component, TypeaheadSelector);
                assert.equal(BEATLES, selector.props.options);
            });
        });

        context('reset selection button', () => {

            beforeEach(() => {
                this.sinon = sinon.sandbox.create();
                this.selectSpy = this.sinon.spy();
            });

            afterEach(() => {
                this.sinon.restore();
            });

            it('does not render reset button when nothing is selected', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } allowReset={true}
                                                                          onOptionSelected={this.selectSpy}/>);
                let resetButton = TestUtils.scryRenderedDOMComponentsWithTag(component, 'button');
                assert.equal(0, resetButton.length);
            });

            it('does not render reset button when it is forbidden by properties', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } allowReset={false}
                                                                          onOptionSelected={this.selectSpy}/>);
                let resetButton = TestUtils.scryRenderedDOMComponentsWithTag(component, 'button');
                assert.equal(0, resetButton.length);
            });

            it('resets selection value when reset button is clicked', () => {
                const component = TestUtils.renderIntoDocument(<Typeahead options={ BEATLES } allowReset={true}
                                                                          onOptionSelected={this.selectSpy}/>);
                component.selectOption(BEATLES[0]);
                assert.equal(BEATLES[0], component.state.entryValue);
                assert.equal(BEATLES[0], component.state.selection);
                let resetButton = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
                TestUtils.Simulate.click(resetButton);
                assert.equal('', component.state.entryValue);
                assert.equal('', component.state.selection);
                assert(this.selectSpy.calledWith(null));
            });
        });
    });
});
