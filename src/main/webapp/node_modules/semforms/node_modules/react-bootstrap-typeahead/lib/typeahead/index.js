'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var React = require('react');
var ReactDOM = require('react-dom');
var TypeaheadSelector = require('./selector');
var KeyEvent = require('../keyevent');
var fuzzy = require('fuzzy');
var classNames = require('classnames');
var FormGroup = require('react-bootstrap').FormGroup;
var InputGroup = require('react-bootstrap').InputGroup;
var FormControl = require('react-bootstrap').FormControl;
var ControlLabel = require('react-bootstrap').ControlLabel;
var Button = require('react-bootstrap').Button;
var Glyphicon = require('react-bootstrap').Glyphicon;

var IDENTITY_FN = function IDENTITY_FN(input) {
    return input;
};
var SHOULD_SEARCH_VALUE = function SHOULD_SEARCH_VALUE(input) {
    return input && input.trim().length > 0;
};
var _generateAccessor = function _generateAccessor(field) {
    return function (object) {
        return object[field];
    };
};

var scheduledEvent = null;

function scheduleEvent(event) {
    scheduledEvent = setTimeout(event, 200);
}

function clearScheduledEvent() {
    if (scheduledEvent) {
        clearTimeout(scheduledEvent);
        scheduledEvent = null;
    }
}

/**
 * A "typeahead", an auto-completing text input
 *
 * Renders an text input that shows options nearby that you can use the
 * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.
 */
var Typeahead = React.createClass({
    displayName: 'Typeahead',

    propTypes: {
        name: React.PropTypes.string,
        customClasses: React.PropTypes.object,
        maxVisible: React.PropTypes.number,
        options: React.PropTypes.array,
        allowCustomValues: React.PropTypes.number,
        defaultValue: React.PropTypes.string,
        value: React.PropTypes.string,
        placeholder: React.PropTypes.string,
        textarea: React.PropTypes.bool,
        inputProps: React.PropTypes.object,
        onOptionSelected: React.PropTypes.func,
        onChange: React.PropTypes.func,
        onKeyDown: React.PropTypes.func,
        onKeyUp: React.PropTypes.func,
        onFocus: React.PropTypes.func,
        onBlur: React.PropTypes.func,
        filterOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        displayOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        formInputOption: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.func]),
        defaultClassNames: React.PropTypes.bool,
        customListComponent: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.func]),
        optionsButton: React.PropTypes.bool, // Whether to show a button which opens a list of all available options
        allowReset: React.PropTypes.bool, // Whether to allow reset of the selected value
        validation: React.PropTypes.oneOf(['success', 'warning', 'error']),
        size: React.PropTypes.oneOf(['sm', 'small', 'lg', 'large'])
    },

    getDefaultProps: function getDefaultProps() {
        return {
            options: [],
            customClasses: {},
            allowCustomValues: 0,
            defaultValue: '',
            value: null,
            placeholder: "",
            textarea: false,
            inputProps: {},
            onOptionSelected: function onOptionSelected(option) {},
            onChange: function onChange(event) {},
            onKeyDown: function onKeyDown(event) {},
            onKeyUp: function onKeyUp(event) {},
            onFocus: function onFocus(event) {},
            onBlur: function onBlur(event) {},
            filterOption: null,
            defaultClassNames: true,
            customListComponent: TypeaheadSelector,
            optionsButton: false,
            allowReset: false
        };
    },

    getInitialState: function getInitialState() {
        return {
            // The currently visible set of options
            visible: this.getOptionsForValue(this.props.defaultValue, this.props.options),

            // This should be called something else, "entryValue"
            entryValue: this.props.value || this.props.defaultValue,

            // A valid typeahead value
            selection: this.props.value,

            // Last valid typeahead value. Useful for resetting value when input is edited but nothing is selected
            lastValidOption: this.props.value,

            // Whether to show options even though nothing has been typed in
            showOptions: false,

            // Index of the selection
            selectionIndex: null
        };
    },

    getOptionsForValue: function getOptionsForValue(value, options) {
        if (!SHOULD_SEARCH_VALUE(value)) {
            return options;
        }
        var filterOptions = this._generateFilterFunction();
        var result = filterOptions(value, options);
        if (this.props.maxVisible) {
            result = result.slice(0, this.props.maxVisible);
        }
        return result;
    },

    /**
     * Gets currently visible options.
     */
    getCurrentOptions: function getCurrentOptions() {
        return this.state.visible;
    },

    _onPageClick: function _onPageClick(e) {
        if (!this._withinOptionsToggle(e) && !this._withinResultList(e) && this.state.showOptions) {
            this.setState({ showOptions: false });
        }
        return true;
    },

    _withinOptionsToggle: function _withinOptionsToggle(e) {
        if (!this.optionsToggle) {
            return false;
        }
        return this._withinRect(e, ReactDOM.findDOMNode(this.optionsToggle).getBoundingClientRect());
    },

    _withinResultList: function _withinResultList(e) {
        return this._withinRect(e, ReactDOM.findDOMNode(this.sel).getBoundingClientRect());
    },

    _withinRect: function _withinRect(e, rect) {
        // Don't forget that root is top left corner, so rect.bottom is always >= rect.top
        return e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
    },

    setEntryText: function setEntryText(value) {
        ReactDOM.findDOMNode(this.entry).value = value;
        this._onTextEntryUpdated();
    },

    getEntryText: function getEntryText() {
        return this.state.entryValue;
    },

    focus: function focus() {
        ReactDOM.findDOMNode(this.entry).focus();
    },

    showOptions: function showOptions() {
        this.setState({ showOptions: true });
    },

    hideOptions: function hideOptions() {
        this.setState({ showOptions: false });
    },

    _hasCustomValue: function _hasCustomValue() {
        return !!(this.props.allowCustomValues > 0 && this.state.entryValue.length >= this.props.allowCustomValues && this.state.visible.indexOf(this.state.entryValue) < 0);
    },

    _getCustomValue: function _getCustomValue() {
        if (this._hasCustomValue()) {
            return this.state.entryValue;
        }
        return null;
    },

    _renderIncrementalSearchResults: function _renderIncrementalSearchResults() {
        var _this = this;

        var options = this.state.visible;
        // If not forced to show options
        if (!this.state.showOptions) {
            window.removeEventListener('mousedown', this._onPageClick, false);
            // Nothing has been entered into the textbox
            if (!this.state.entryValue) {
                return "";
            }

            // Something was just selected
            if (this.state.selection) {
                return "";
            }
        } else {
            // Show all options even though something might have been selected
            options = this.getOptionsForValue('', this.props.options);
            window.addEventListener('mousedown', this._onPageClick, false);
        }

        return React.createElement(this.props.customListComponent, {
            ref: function ref(c) {
                return _this.sel = c;
            }, options: options,
            onOptionSelected: this._onOptionSelected,
            customValue: this._getCustomValue(),
            customClasses: this.props.customClasses,
            selectionIndex: this.state.selectionIndex,
            defaultClassNames: this.props.defaultClassNames,
            displayOption: this._generateOptionToStringFor(this.props.displayOption) });
    },

    getSelection: function getSelection() {
        var index = this.state.selectionIndex;
        if (this._hasCustomValue()) {
            if (index === 0) {
                return this.state.entryValue;
            } else {
                index--;
            }
        }
        return this.state.visible[index];
    },

    _onOptionSelected: function _onOptionSelected(option, event) {
        this.selectOption(option);
        return this.props.onOptionSelected(option, event);
    },

    selectOption: function selectOption(option) {
        clearScheduledEvent();
        window.removeEventListener('mousedown', this._onPageClick, false);
        var nEntry = ReactDOM.findDOMNode(this.entry);
        // nEntry.focus();

        var displayOption = this._generateOptionToStringFor(this.props.displayOption),
            optionString = displayOption(option, 0);

        var formInputOption = this._generateOptionToStringFor(this.props.formInputOption || displayOption),
            formInputOptionString = formInputOption(option);

        nEntry.value = optionString;
        this.setState({
            visible: this.getOptionsForValue(optionString, this.props.options),
            selection: formInputOptionString,
            lastValidOption: option,
            showOptions: false,
            entryValue: optionString
        });
    },

    resetSelection: function resetSelection() {
        var nEntry = ReactDOM.findDOMNode(this.entry);
        nEntry.value = '';
        this.setState({
            visible: this.props.options,
            lastValidOption: undefined,
            selection: '',
            entryValue: ''
        });
    },

    _onResetSelectionClick: function _onResetSelectionClick() {
        this.resetSelection();
        this.props.onOptionSelected(null);
    },

    _onTextEntryUpdated: function _onTextEntryUpdated() {
        var value = ReactDOM.findDOMNode(this.entry).value;
        this.setState({
            visible: this.getOptionsForValue(value, this.props.options),
            selection: '',
            showOptions: false,
            entryValue: value
        });
    },

    _onEnter: function _onEnter(event) {
        var selection = this.getSelection();
        if (!selection) {
            return this.props.onKeyDown(event);
        }
        return this._onOptionSelected(selection, event);
    },

    _onEscape: function _onEscape() {
        this.setState({
            showOptions: false,
            selectionIndex: null
        });
    },

    _onTab: function _onTab(event) {
        var selection = this.getSelection();
        var option = selection ? selection : this.state.visible.length > 0 ? this.state.visible[0] : null;

        if (option === null && this._hasCustomValue()) {
            option = this._getCustomValue();
        }

        if (option !== null) {
            return this._onOptionSelected(option, event);
        }
    },

    eventMap: function eventMap(event) {
        var events = {};

        events[KeyEvent.DOM_VK_UP] = this.navUp;
        events[KeyEvent.DOM_VK_DOWN] = this.navDown;
        events[KeyEvent.DOM_VK_RETURN] = events[KeyEvent.DOM_VK_ENTER] = this._onEnter;
        events[KeyEvent.DOM_VK_ESCAPE] = this._onEscape;
        events[KeyEvent.DOM_VK_TAB] = this._onTab;

        return events;
    },

    _nav: function _nav(delta) {
        if (!this._hasHint()) {
            return;
        }
        var newIndex = this.state.selectionIndex === null ? delta == 1 ? 0 : delta : this.state.selectionIndex + delta,
            length = this.state.visible.length;
        if (this._hasCustomValue()) {
            length += 1;
        }

        if (newIndex < 0) {
            newIndex += length;
        } else if (newIndex >= length) {
            newIndex -= length;
        }

        this.setState({ selectionIndex: newIndex });
    },

    navDown: function navDown() {
        this._nav(1);
    },

    navUp: function navUp() {
        this._nav(-1);
    },

    _onChange: function _onChange(event) {
        if (this.props.onChange) {
            this.props.onChange(event);
        }

        this._onTextEntryUpdated();
    },

    _onKeyDown: function _onKeyDown(event) {
        // If there are no visible elements, don't perform selector navigation.
        // Just pass this up to the upstream onKeydown handler.
        // Also skip if the user is pressing the shift key, since none of our handlers are looking for shift
        if (!this._hasHint() || event.shiftKey) {
            return this.props.onKeyDown(event);
        }

        var handler = this.eventMap()[event.keyCode];

        if (handler) {
            handler(event);
        } else {
            return this.props.onKeyDown(event);
        }
        // Don't propagate the keystroke back to the DOM/browser
        event.preventDefault();
    },

    _onBlur: function _onBlur() {
        var _this2 = this;

        if (this.state.lastValidOption === undefined) {
            return;
        }
        // This is a nasty hack, but we need to somehow postpone this execution until after the click event finishes
        // in case blur is a result of the user clicking on an option in the result list.
        scheduleEvent(function () {
            if (_this2.state.lastValidOption !== null && (0, _typeof3.default)(_this2.state.lastValidOption) === 'object') {
                _this2.selectOption(_this2.state.lastValidOption);
            } else {
                _this2.setEntryText(_this2.props.value || _this2.props.defaultValue);
                _this2.setState({ visible: [], selection: _this2.props.value });
            }
        });
        this.props.onBlur();
    },

    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        this.setState({
            visible: this.getOptionsForValue(ReactDOM.findDOMNode(this.entry).value, nextProps.options)
        });
    },

    componentWillUnmount: function componentWillUnmount() {
        window.removeEventListener('mousedown', this._onPageClick, false);
        clearScheduledEvent();
    },

    _onToggleShowOptions: function _onToggleShowOptions() {
        if (this.state.entryValue && !this.state.selection) {
            return;
        }
        this.setState({ showOptions: !this.state.showOptions });
    },

    render: function render() {
        var controlProps = {
            bsSize: this.props.size,
            validationState: this.props.validation,
            controlId: this.props.controlId
        },
            classes = {
            typeahead: this.props.defaultClassNames
        };
        classes[this.props.className] = !!this.props.className;
        var classList = classNames(classes);

        return React.createElement(
            'div',
            { className: classList },
            this._renderHiddenInput(),
            React.createElement(
                FormGroup,
                controlProps,
                this.props.label && React.createElement(
                    ControlLabel,
                    null,
                    this.props.label
                ),
                this._renderInput()
            ),
            this._renderIncrementalSearchResults()
        );
    },

    _renderHiddenInput: function _renderHiddenInput() {
        if (!this.props.name) {
            return null;
        }

        return React.createElement(FormControl, {
            type: 'hidden',
            name: this.props.name,
            value: this.state.selection ? this.state.selection : ''
        });
    },

    _renderInput: function _renderInput() {
        var _this3 = this;

        var inputClasses = {};
        inputClasses[this.props.customClasses.input] = !!this.props.customClasses.input;
        var inputClassList = classNames(inputClasses),
            input = React.createElement(FormControl, (0, _extends3.default)({ ref: function ref(c) {
                return _this3.entry = c;
            }, type: 'text'
        }, this.props.inputProps, {
            placeholder: this.props.placeholder,
            className: inputClassList,
            value: this.state.entryValue,
            onChange: this._onChange,
            onKeyDown: this._onKeyDown,
            onKeyUp: this.props.onKeyUp,
            onFocus: this.props.onFocus,
            onBlur: this._onBlur })),
            resetButton = this._renderResetButton(),
            optionsButton = this._renderShowOptionsButton();
        if (resetButton || optionsButton) {
            return React.createElement(
                InputGroup,
                null,
                input,
                resetButton,
                optionsButton
            );
        } else {
            return input;
        }
    },

    _renderShowOptionsButton: function _renderShowOptionsButton() {
        var _this4 = this;

        if (!this.props.optionsButton) {
            return null;
        }
        var buttonProps = {};
        if (this.props.size) {
            buttonProps.bsSize = this.props.size;
        }
        return React.createElement(
            InputGroup.Button,
            null,
            React.createElement(
                Button,
                (0, _extends3.default)({ ref: function ref(c) {
                        return _this4.optionsToggle = c;
                    }, title: 'Show all options',
                    onClick: this._onToggleShowOptions }, buttonProps),
                React.createElement(Glyphicon, { glyph: 'triangle-bottom' })
            )
        );
    },

    _renderResetButton: function _renderResetButton() {
        var buttonProps = {
            style: { borderRadius: this.props.optionsButton ? '0' : '0 3px 3px 0', margin: '0 0 0 -1px' }
        };
        if (this.props.size) {
            buttonProps.bsSize = this.props.size;
        }
        return this.props.allowReset && this.state.selection ? React.createElement(
            InputGroup.Button,
            null,
            React.createElement(
                Button,
                (0, _extends3.default)({ onClick: this._onResetSelectionClick, title: 'Reset selection' }, buttonProps),
                React.createElement(Glyphicon, {
                    glyph: 'remove' })
            )
        ) : null;
    },

    _generateFilterFunction: function _generateFilterFunction() {
        var filterOptionProp = this.props.filterOption;
        if (typeof filterOptionProp === 'function') {
            return function (value, options) {
                return options.filter(function (o) {
                    return filterOptionProp(value, o);
                });
            };
        } else {
            var _ret = function () {
                var mapper = void 0;
                if (typeof filterOptionProp === 'string') {
                    mapper = _generateAccessor(filterOptionProp);
                } else {
                    mapper = IDENTITY_FN;
                }
                return {
                    v: function v(value, options) {
                        return fuzzy.filter(value, options, { extract: mapper }).map(function (res) {
                            return options[res.index];
                        });
                    }
                };
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
        }
    },

    _generateOptionToStringFor: function _generateOptionToStringFor(prop) {
        if (typeof prop === 'string') {
            return _generateAccessor(prop);
        } else if (typeof prop === 'function') {
            return prop;
        } else {
            return IDENTITY_FN;
        }
    },

    _hasHint: function _hasHint() {
        return this.state.visible.length > 0 || this._hasCustomValue();
    }
});

module.exports = Typeahead;